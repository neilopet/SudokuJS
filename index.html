<html>
<head>
<title>SudokuJS</title>
<script>
/*
 * 1) Get empty cells
 * 2) Iterate each empty cell
 * 2a) Get cell buddies
 * 2b) Evaluate possibilities
 * 3) Solve single solution cells
 * 4) Iterate each bivalue cell (pivot: XY)
 * 4a) Identify pincers (cells XZ, YZ that share common X or common Y)
 * 4b) Eliminate all pincer intersect values from box containing XZ or YZ
 */

var validMoves = [1, 2, 3, 4, 5, 6, 7, 8, 9];

/*
// Solvable with Forced Entry alone
var matrix = [
	['', 1, 5, '', 6, 3, '', 4, ''],
	['', '', '', '', '', '' ,'', '', ''],
	[4, '', '', 1, '', 8, 5, '', ''],
	['', 6, '', 8, '', '', '', 2, 3],
	[2, '', '', 4, 3, 9, '', '', 8],
	[1, 3, '', '', '', 6, '', 5, ''],
	['', '', 9, 3, '', 1, '', '', 7],
	['', '', '', '', '', '', '', '', ''],
	['', 4, '', 7, 5, '', 1, 8, '']
];

// unsolvable - requires using techniques such as X Wing, XY Wing, etc.
var matrix = [
	['', 1, '', '', '', '', 9, '', 4],
	[2, '', '', 9, '', '', 7, 8, ''],
	[6, 7, 9, '', '', 3, '', '', ''],
	[4, '', '', '', 9, '', 5, '', ''],
	['', '', '', 2, '', 4, '', '', ''],
	['', '', 1, '', 7, '', '', '', 2],
	['', '', '', 8, '', '', 3, 4, 5],
	['', 2, 4, '', '', 6, '', '', 7],
	[1, '', 5, '', '', '', '', 2, '']
];

// Solvable with Forced Entry alone
var matrix = [
	['', '', 3, 5, '', 9, '', '', ''],
	['', 6, '', '', '', '', '', 2, 7],
	['', '', 8, '', '', 2, 4, 9, ''],
	[3, '', '', '', 2, '', 7, '', 5],
	['', '', 9, '', '', '', 8, '', ''],
	[5, '', 2, '', 8, '', '', '', 9],
	['', 9, 1, 4, '', '', 2, '', ''],
	[4, 3, '', '', '', '', '', 7, ''],
	['', '', '', 6, '', 5, 1, '', '']
];

// Solvable with Forced Entry alone
var matrix = [
	['', '', '', '', '', '', 7, '', ''],
	['', '', 7, 4, 9, 2, '', '', ''],
	[4, 3, 6, '', 8, '', '', '', ''],
	[7, '', '', 1, '', '', 2, '', 3],
	[1, 2, '', '', '', '', '', 8, 4],
	[6, '', 5, '', '', 8, '', '', 1],
	['', '', '', '', 2, '', 6, 1, 5],
	['', '', '', 7, 6, 5, 4, '', ''],
	['', '', 9, '', '', '', '', '', '']
];
*/

// unsolvable - requires using techniques such as X Wing, XY Wing, etc.
var matrix = [
	['', 1, '', '', '', '', 9, '', 4],
	[2, '', '', 9, '', '', 7, 8, ''],
	[6, 7, 9, '', '', 3, '', '', ''],
	[4, '', '', '', 9, '', 5, '', ''],
	['', '', '', 2, '', 4, '', '', ''],
	['', '', 1, '', 7, '', '', '', 2],
	['', '', '', 8, '', '', 3, 4, 5],
	['', 2, 4, '', '', 6, '', '', 7],
	[1, '', 5, '', '', '', '', 2, '']
];

var start = new Date();
var solution = solve(matrix);

if (!checkSolution(solution)) {
	solution = solvePossibilities( solution );
}

function loadMatrix() {
	printMatrix(solution);
}

//////////////////////////////////////////
// helper methods
//

function Point(x, y) { return { x: x, y: y }; }

function printMatrix( matrix ) {
	var outTable = document.getElementById('outTable');
	for (var i = 0; i < matrix[0].length; i++) {
		for (var j = 0; j < matrix[i].length; j++) {
			var row = outTable.getElementsByTagName('tr')[i];
			var cell = row.getElementsByTagName('td')[j];
			var val = matrix[i][j];
			if (val.length > 1) {
				val = '<span style="color:#f00">' + val + '</span>';
			}
			cell.innerHTML = val;
		}
	}
}

function solvePossibilities( matrix ) {
	var newSolution = false;
	for (var i = 0; i < matrix.length; i++) {
		for(var j = 0; j < matrix[i].length; j++) {
			var cur = get(Point(j, i));
			if (cur != '') {
				continue;
			}
			var diversity = unique(getCellDiversity(Point(j, i)));
			var possibleValues = diff(validMoves, diversity);
			if (possibleValues.length == 1) {
				newSolution = true;
				matrix[i][j] = possibleValues[0];
			}
			else if (possibleValues.length >= 2) {
				matrix[i][j] = possibleValues;
			}
		}
	}
	if (newSolution) {
		return solve(matrix);
	}
	else {
		return matrix;
	}
}

function solve( matrix ) {
	var newSolution = false;
	for (var i = 0; i < matrix.length; i++) {
		for(var j = 0; j < matrix[i].length; j++) {
			var cur = get(Point(j, i));
			if (cur != '') {
				continue;
			}
			var diversity = unique(getCellDiversity(Point(j, i)));
			var possibleValues = diff(validMoves, diversity);
			if (possibleValues.length == 1) {
				newSolution = true;
				matrix[i][j] = possibleValues[0];
			}
		}
	}
	if (newSolution) {
		return solve(matrix);
	}
	else {
		return matrix;
	}
}

function get( point ) {
	return matrix[point.y][point.x];
}

function diff( array1, array2 ) {
	var ret = [];
	for(var i = 0; i < array1.length; i++) {
		var found = false;
		for(var j = 0; j < array2.length; j++) {
			if (array1[i] == array2[j]) {
				found = true;
				break;
			}
		}
		if (!found) {
			ret.push( array1[i] );
		}
	}
	return ret;
}

function checkSolution( matrix ) {
	return (check(matrix) 
		&& check(transpose(matrix)));
}

function check( matrix ) {
	var rowSum = sigmaN( matrix[0].length );
	for (var i = 0; i < matrix[0].length; i++) {
		var sum = 0;
		for (var j = 0; j < matrix[i].length; j++) {
			sum += matrix[i][j];
		}
		if (sum != rowSum) {
			return false;
		}
	}
	return true;
}

function sigmaN( num ) {
	var ret = 0;
	for( var i = 1; i <= num; ret += i, i++)
		;
	return ret;
}

function getCellDiversity( point ) {
	/* get X, Y givens */
	var givensX = [], givensY = [];
	for (var i = 0; i < matrix[0].length; i++) {
		if (matrix[point.y][i] != '') {
			givensX.push( matrix[point.y][i] );
		}
		if (matrix[i][point.x] != '') {
			givensY.push( matrix[i][point.x] );
		}
	}
	/* get Block */
	var givensBlock = getNBlock( point );
	//console.log({ x: givensX, y: givensY, z: givensBlock });
	return quickSort(givensX.concat(givensY, givensBlock));
}

function unique( array ) {
	var ret = [];
	for (var i = 0, j = -1; i < array.length; i++) {
		if (ret[j] != array[i]) {
			ret.push(array[i]);
			j++;
		}
	}
	return ret;	
}

function quickSort( array ) {
	if (array.length < 1) {
		return array;
	}
	var left = [], right = [], pivot = array[0];
	for (var i = 1; i < array.length; i++) {
		if (array[i] < pivot) {
			left.push(array[i]);
		}
		else {
			right.push(array[i]);
		}
	}
	return quickSort(left).concat(pivot, quickSort(right));
}

function getNBlock( point ) {
	var coord = getNBlockPoint( point );
	var ret = [];
	for (var i = coord.y, ilim = (coord.y + 3); i < ilim; i++) {
		for (var j = coord.x, jlim = (coord.x + 3); j < jlim; j++) {
			if (matrix[i][j] != '') {
				ret.push(matrix[i][j]);
			}
		}
	}
	return ret;
}

function getNBlockPoint( point ) {
	if (point.x < 3) {
		if (point.y < 3) {
			return Point(0, 0);
		}
		else if (point.y < 6) {
			return Point(0, 3);
		}
		else {
			return Point(0, 6);
		}
	}
	else if (point.x < 6) {
		if (point.y < 3) {
			return Point(3, 0);
		}
		else if (point.y < 6) {
			return Point(3, 3);
		}
		else {
			return Point(3, 6);
		}	
	}
	else {
		if (point.y < 3) {
			return Point(6, 0);
		}
		else if (point.y < 6) {
			return Point(6, 3);
		}
		else {
			return Point(6, 6);
		}
	}
}

function transpose( array ) {
	return array[0].map(function(col, i) { 
		return array.map(function(row) { 
			return row[i];
		})
	});
}
</script>
<style>
table {
	border: 5px solid #000;
	border-collapse: collapse;
	table-layout: fixed;
}
table td {
	padding: 10px;
	border: 1px solid #333;
	width: 50px;
	height: 50px;
	max-width: 50px;
	text-align: center;
}
table td:nth-child(3),
table td:nth-child(6) {
	border-right: 5px solid #333;	
}
table tr:nth-child(3) td,
table tr:nth-child(6) td {
	border-bottom: 5px solid #333;		
}
</style>
</head>
<body onload="loadMatrix();">

<table id="outTable">
	<tr>
		<td>1</td>
		<td>2</td>
		<td>3</td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td></td>
	</tr>
</table>

</body>
</html>
